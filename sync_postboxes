#!/usr/bin/perl
use Modern::Perl;
use List::Util qw(min max);
use List::MoreUtils qw(uniq);
use Tie::RefHash;
use Getopt::Long;
use Date::Manip;
use lib '.';
use OSM;
use Dracos;

our ($opt_cautious, $opt_timestamp) = (0, 1);
(GetOptions('cautious', 'timestamp!') && @ARGV == 1)
    or die <<END
usage: $0 [--cautious] [--no-timestamp] postcode-prefix
e.g. $0 E10
END
    ;
my $postcode_prefix = shift;
$postcode_prefix =~ /\A[A-Z]+[0-9]+\z/
    or die "bad postcode prefix $postcode_prefix\n";
my @postbox_data
    = grep { ($_->{postal_code} // '') =~ /\A$postcode_prefix\s/o }
      Dracos::get_data;
die "no Dracos postboxes found with postcode prefix $postcode_prefix"
    if not @postbox_data;
warn scalar(@postbox_data), " Dracos postboxes found in $postcode_prefix";
if ($opt_cautious) {
    foreach (@postbox_data) {
	delete $_->{$_} foreach qw(postal_code addr:housenumber addr:street);
    }
}

my @lats = map { $_->{lat} } @postbox_data;
my @lons = map { $_->{lon} } @postbox_data;
my $min_lat = min @lats;
my $max_lat = max @lats;
my $min_lon = min @lons;
my $max_lon = max @lons;

# Maximum distance for matching two postbox positions.
my $MAX_DISTANCE = 100;

# Pad the bounding box to find postboxes near the positions given.
my $centre_lat = ($min_lat + $max_lat) / 2;
my $centre_lon = ($min_lon + $max_lon) / 2;
my $padding_lat
    = OSM::height_to_lat_degrees $centre_lat, $centre_lon, $MAX_DISTANCE;
my $padding_lon
    = OSM::width_to_lon_degrees $centre_lat, $centre_lon, $MAX_DISTANCE;
$min_lat -= $padding_lat;
$max_lat += $padding_lat;
$min_lon -= $padding_lon;
$max_lon += $padding_lon;

# Sanity check we're not getting too much.
my $MAX_FETCH_SIZE = 30_000;
my $corner_distance = int OSM::distance $min_lat, $min_lon, $max_lat, $max_lon;
die "too large an area to fetch: $corner_distance metres corner to corner\n"
    if $corner_distance > $MAX_FETCH_SIZE;
warn "fetching area $corner_distance metres from corner to corner\n";

my @bbox = ($min_lon, $min_lat, $max_lon, $max_lat);
OSM::show_slippy_map_link_for_bbox @bbox;
my $data = OSM::get_area_bbox @bbox;

warn "parsing\n";
my @nodes = OSM::parse_nodes $data;
my @osm_postbox_nodes
    = grep { exists $_->{amenity} and $_->{amenity} eq 'post_box' } @nodes;
warn scalar(@osm_postbox_nodes) . " nearby post boxes found in OSM\n";

# Given one data point, find the closest to it in a list of others,
# subject to $MAX_DISTANCE.
#
sub find_closest {
    my ($box, @others) = @_;
    my $lat = $box->{lat};
    my $lon = $box->{lon};
    my ($closest, $closest_distance);
    foreach my $n (@others) {
	my ($nlat, $nlon) = ($n->{lat}, $n->{lon});
	my $distance = OSM::distance $lat, $lon, $nlat, $nlon;
	next if $distance > $MAX_DISTANCE;
	if (not defined $closest_distance or $distance < $closest_distance) {
	    $closest = $n;
	    $closest_distance = $distance;
	}
    }
    return $closest;
}

# Find unambiguous is-closest-to matches.
my %closest_osm_to_dracos;
tie %closest_osm_to_dracos, 'Tie::RefHash' or die;
foreach (@postbox_data) {
    my $closest = find_closest $_, @osm_postbox_nodes;
    $closest_osm_to_dracos{$_} = $closest if $closest;
}
my %closest_dracos_to_osm;
tie %closest_dracos_to_osm, 'Tie::RefHash' or die;
foreach (@osm_postbox_nodes) {
    my $closest = find_closest $_, @postbox_data;
    $closest_dracos_to_osm{$_} = $closest if $closest;
}
my @unambiguous;
foreach my $d (keys %closest_osm_to_dracos) {
    my $o = $closest_osm_to_dracos{$d};
    my $got = $closest_dracos_to_osm{$o};
    if (defined $got and $got eq $d) {
	push @unambiguous, [ $d, $o ];
    }
}

my @attr_changes;
use constant EPSILON => 1;
foreach (@unambiguous) {
    my %dracos = %{$_->[0]};
    my %osm = %{$_->[1]};
    my %osm_new = %osm;
    my $changed = 0;
    my $distance = OSM::distance delete($dracos{lat}), delete($dracos{lon}),
                                 delete($osm{lat}), delete($osm{lon});
    delete($osm{amenity}) eq 'post_box' or die;
    my $id = delete $osm{id};
    my $version = delete $osm{version};

    # Check postal code.
    my $dracos_postal_code = delete $dracos{postal_code};
    my $osm_postal_code = delete $osm{postal_code};
    if (defined $dracos_postal_code and defined $osm_postal_code) {
	if ($dracos_postal_code eq $osm_postal_code) {
	    # OK.
	}
	elsif ($osm_postal_code =~ /\A${dracos_postal_code}\d+\z/) {
	    # The OSM one is more detailed.  Do not warn.
	}
	elsif ($dracos_postal_code =~ /\A$osm_postal_code/) {
	    $osm_new{postal_code} = $dracos_postal_code;
	    $changed = 1;
	}
	else {
	    warn qq{$id $version: postal_code $osm_postal_code is inconsistent with Dracos $dracos_postal_code\n};
	}
    }

    # Check 'ref' - sometimes on the map two are given.
    if (defined $dracos{ref} and defined $osm{ref} and $osm{ref} =~ tr/;//) {
	my $d = delete $dracos{ref};
	my @o = split /;\s*/, delete $osm{ref};
	if (@o ~~ $d) {
	    # OK, this ref is there, plus some others.
	}
	else {
	    warn qq{$id $version: refs (@o) are inconsistent with Dracos $d\n};
	}
    }

    foreach (sort keys %dracos) {
        my $d = $dracos{$_};
        my $o = $osm{$_};
        if (not defined $o) {
	    $osm_new{$_} = $d;
	    $changed = 1;
	}
	elsif ($d ne $o) {
	    warn qq{$id $version: discrepancy: Dracos $_="$d" vs OSM $_="$o"\n};
	}
    }

    if ($changed) {
	$osm_new{source} //= 'dracos';
	push @attr_changes, \%osm_new;
    }
}

my %has_unambiguous;
foreach (@unambiguous) {
    foreach (@$_) {
	$has_unambiguous{$_}++ && die;
    }
}

my @new_nodes;
my %suggested;
foreach my $d (@postbox_data) {
    next if $has_unambiguous{$d};
    my $lat = $d->{lat};
    my $lon = $d->{lon};
    my $loc1 = $d->{loc1};
    my $ref = $d->{ref};
    my $postal_code = $d->{postal_code};
    my $operator = $d->{operator};

    # Find nearby unmatched OSM nodes.
    my @osm_with_distance
	= map { [ $_, OSM::distance $lat, $lon, $_->{lat}, $_->{lon} ] }
    @osm_postbox_nodes;
    @osm_with_distance = grep { $_->[1] <= $MAX_DISTANCE } @osm_with_distance;
    @osm_with_distance
	= reverse sort { $a->[1] <=> $b->[1] } @osm_with_distance;

    if (@osm_with_distance) {
	my $msg = sprintf 'to add at (%.6f, %.6f), ref=%s', $lat, $lon, $ref;
	 warn "$msg\n";
	 warn "...but has nearby OSM postboxes:\n";
	foreach (@osm_with_distance) {
	    my ($n, $distance) = @$_;
	    $distance = int $distance;
	    print STDERR "  $n->{id} $n->{version}: $distance metres away ($n->{lat}, $n->{lon})\n";
            print STDERR '   (already matched)' if $has_unambiguous{$n};
            print STDERR "\n";
	    $suggested{$n} = 1;
	}
    }
    else {
	# Nothing nearby, we can safely add the new node.
	my $node_id = -(scalar(@new_nodes) + 1);
	my %h = (
	    id => $node_id, lat => $lat, lon => $lon,
	    amenity => 'post_box', ref => $ref, 
	    operator => $operator,
	    source => 'dracos', 'dracos:verified' => 'no',
	    );
	foreach ('addr:housenumber', 'addr:street', 'postal_code') {
	    $h{$_} = $d->{$_} if exists $d->{$_};
	}
	push @new_nodes, \%h;
    }
}

# Don't warn about every OSM box in that rectangle, just those that
# have the ref asked for.  (TODO find a convex hull or something.)
#
foreach (@osm_postbox_nodes) {
    next if $has_unambiguous{$_};
    next if $suggested{$_};
    my $ref = $_->{ref};
    next if not defined $ref;
    next unless $ref =~ /\A$postcode_prefix /o;
    warn "$_->{id}: not in Dracos data\n";
}

my $timestamp;
$timestamp = UnixDate 'now', '%O' if $opt_timestamp; # FIXME requires UTC time
my $changeset = 999;
sub write_node {
    my %h = %{shift()};

    # First get out the standard attrs.
    my %a;
    $a{$_} = delete $h{$_} foreach qw(id lat lon version);
    $a{version} //= 0;
    $a{timestamp} = $timestamp if $opt_timestamp;
    $a{changeset} = $changeset;
    my $attr_str
	= join ' ', map { $_ . '="' . delete($a{$_}) . '"' } sort keys %a;
    say "    <node $attr_str>";
    foreach (sort keys %h) {
	say qq{      <tag k="$_" v="$h{$_}" />};
    }
    say '    </node>';
}

my $gunk = 'version="0.3" generator="sync_postboxes"';
exit if not @attr_changes and not @new_nodes;
say "<osmChange $gunk>";
foreach (sort { $a->{id} <=> $b->{id} } @attr_changes) {
    say "  <modify $gunk>";
    write_node $_;
    say '  </modify>';
}
foreach (reverse sort { $a->{id} <=> $b->{id} } @new_nodes) {
    say "  <create $gunk>";
    write_node $_;
    say '  </create>';
}
say '</osmChange>';

    
