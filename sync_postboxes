#!/usr/bin/perl
use Modern::Perl;
use File::Slurp;
use List::Util qw(min max);
use List::MoreUtils qw(uniq);
use Tie::RefHash;
use lib '.';
use OSM;

my $postboxes_data_file = 'postboxes.tsv';
if (not -e $postboxes_data_file) {
    my $uri = 'http://www.dracos.co.uk/play/locating-postboxes/export.php';
    die "$postboxes_data_file not there, fetch it from:\n$uri\n";
}

die "usage: $0 postcode-prefix\ne.g. $0 E10\n" if @ARGV != 1;
my $postcode_prefix = shift;
$postcode_prefix =~ /\A[A-Z]+[0-9]+\z/
    or die "bad postcode prefix $postcode_prefix\n";

my @postbox_data;
foreach (read_file $postboxes_data_file) {
    my %h;
    @h{qw(ref postcode loc1 loc2 lat lon)} = split /\t/;
    next unless $h{ref} =~ /\A$postcode_prefix\s/o;
    die "postcode $h{postcode} does not match ref $h{ref}"
	unless $h{postcode} =~ /\A$postcode_prefix/o;
    foreach (keys %h) {
	delete $h{$_} if $h{$_} !~ /\S/;
    }
    push @postbox_data, \%h;
}
say scalar(@postbox_data),
    " post boxes found in $postboxes_data_file for $postcode_prefix";
die if not @postbox_data;

my @lats = map { $_->{lat} } @postbox_data;
my @lons = map { $_->{lon} } @postbox_data;
my $min_lat = min @lats;
my $max_lat = max @lats;
my $min_lon = min @lons;
my $max_lon = max @lons;

# Maximum distance for matching two postbox positions.
my $MAX_DISTANCE = 100;

# Pad the bounding box to find postboxes near the positions given.
my $centre_lat = ($min_lat + $max_lat) / 2;
my $centre_lon = ($min_lon + $max_lon) / 2;
my $padding_lat
    = OSM::height_to_lat_degrees $centre_lat, $centre_lon, $MAX_DISTANCE;
my $padding_lon
    = OSM::width_to_lon_degrees $centre_lat, $centre_lon, $MAX_DISTANCE;
$min_lat -= $padding_lat;
$max_lat += $padding_lat;
$min_lon -= $padding_lon;
$max_lon += $padding_lon;

# Sanity check we're not getting too much.
my $MAX_FETCH_SIZE = 30_000;
my $corner_distance = int OSM::distance $min_lat, $min_lon, $max_lat, $max_lon;
die "too large an area to fetch: $corner_distance metres corner to corner\n"
    if $corner_distance > $MAX_FETCH_SIZE;
say "fetching area $corner_distance metres from corner to corner";

{
    my ($got_centre_lat, $got_centre_lon, $zoom)
	= OSM::bbox_to_zoom($min_lon, $min_lat, $max_lon, $max_lat);
    say '<http://www.openstreetmap.org/'
	. "?lat=$got_centre_lat&lon=$got_centre_lon&zoom=$zoom>";
}

my $data = OSM::get_area_bbox $min_lon, $min_lat, $max_lon, $max_lat;

say 'parsing';
my @nodes = OSM::parse_nodes $data;
my @osm_postbox_nodes
    = grep { exists $_->{amenity} and $_->{amenity} eq 'post_box' } @nodes;
say scalar(@osm_postbox_nodes), ' nearby post boxes found in OSM';

# Given one data point, find the closest to it in a list of others,
# subject to $MAX_DISTANCE.
#
sub find_closest {
    my ($box, @others) = @_;
    my $lat = $box->{lat};
    my $lon = $box->{lon};
    my ($closest, $closest_distance);
    foreach my $n (@others) {
	my ($nlat, $nlon) = ($n->{lat}, $n->{lon});
	my $distance = OSM::distance $lat, $lon, $nlat, $nlon;
	next if $distance > $MAX_DISTANCE;
	if (not defined $closest_distance or $distance < $closest_distance) {
	    $closest = $n;
	    $closest_distance = $distance;
	}
    }
    return $closest;
}

# Find unambiguous is-closest-to matches.
my %closest_osm_to_dracos;
tie %closest_osm_to_dracos, 'Tie::RefHash' or die;
foreach (@postbox_data) {
    my $closest = find_closest $_, @osm_postbox_nodes;
    $closest_osm_to_dracos{$_} = $closest if $closest;
}
my %closest_dracos_to_osm;
tie %closest_dracos_to_osm, 'Tie::RefHash' or die;
foreach (@osm_postbox_nodes) {
    my $closest = find_closest $_, @postbox_data;
    $closest_dracos_to_osm{$_} = $closest if $closest;
}
my @unambiguous;
foreach my $d (keys %closest_osm_to_dracos) {
    my $o = $closest_osm_to_dracos{$d};
    my $got = $closest_dracos_to_osm{$o};
    if (defined $got and $got eq $d) {
	push @unambiguous, [ $d, $o ];
    }
}

use constant EPSILON => 1;
foreach (@unambiguous) {
    my %dracos = %{$_->[0]};
    my %osm = %{$_->[1]};
    my $distance = OSM::distance delete($dracos{lat}), delete($dracos{lon}),
                                 delete($osm{lat}), delete($osm{lon});
    my ($housenumber, $street, $postcode);
    my $loc1 = delete($dracos{loc1});
    if ($loc1 =~ /\A(\d+) (.+) ([A-Z]+\d+)\z/) {
	($housenumber, $street, $postcode) = ($1, $2, $3);
    }
    elsif ($loc1 =~ /\A(\d+) (.+)\z/) {
	($housenumber, $street) = ($1, $2);
    }
    else {
	$street = $loc1;
    }
    $dracos{'addr:housenumber'} = $housenumber if defined $housenumber;
    $dracos{'addr:street'} = $street if defined $housenumber;
    if (defined $postcode and $dracos{postcode} !~ /\A$postcode /) {
	say "inconsistency in Dracos data: box with $dracos{postcode} has $postcode in loc1";
    }

    # loc2, if present, gives the intersection street.  We don't do
    # anything with this yet, since addr:street holds just the main one.
    #
    delete $dracos{loc2};

    $dracos{postal_code} = delete $dracos{postcode};
    delete($osm{amenity}) eq 'post_box' or die;
    my $id = delete $osm{id};

    # Check postal code.
    my $dracos_postcode = delete $dracos{postal_code};
    my $osm_postcode = delete $osm{postal_code};
    if (defined $dracos_postcode and defined $osm_postcode) {
	if ($dracos_postcode eq $osm_postcode) {
	    # OK.
	}
	elsif ($osm_postcode =~ /\A${dracos_postcode}\d+\z/) {
	    # The OSM one is more detailed.  Do not warn.
	}
	elsif ($dracos_postcode =~ /\A$osm_postcode/) {
	    say qq{$id: change postal_code="$osm_postcode" to postal_code="$dracos_postcode" (more detailed)};
	}
	else {
	    say qq{$id: postal_code $osm_postcode is inconsistent with Dracos $dracos_postcode};
	}
    }

    foreach (sort keys %dracos) {
        my $d = $dracos{$_};
        my $o = $osm{$_};
        if (not defined $o) {
	    say qq{$id: add $_="$d"};
	}
	elsif ($d ne $o) {
	    say qq{$id: discrepancy: Dracos $_="$d" vs OSM $_="$o"};
	}
    }
}

my %has_unambiguous;
foreach (@unambiguous) {
    foreach (@$_) {
	$has_unambiguous{$_}++ && die;
    }
}

my @unmatched_osm = grep { not $has_unambiguous{$_} } @osm_postbox_nodes;
my %suggested;
foreach (@postbox_data) {
    next if $has_unambiguous{$_};
    my $lat = $_->{lat};
    my $lon = $_->{lon};
    printf(qq{to add at (%.6f, %.6f) (%s), ref="%s"\n},
	   $lat, $lon, $_->{loc1}, $_->{ref});

    # Find nearby unmatched OSM nodes.
    my @osm_with_distance
	= map { [ $_, OSM::distance $lat, $lon, $_->{lat}, $_->{lon} ] }
    @unmatched_osm;
    @osm_with_distance = grep { $_->[1] <= $MAX_DISTANCE } @osm_with_distance;
    @osm_with_distance
	= reverse sort { $a->[1] <=> $b->[1] } @osm_with_distance;

    if (@osm_with_distance) {
	say '  nearby OSM postboxes:';
	foreach (@osm_with_distance) {
	    my ($n, $distance) = @$_;
	    $distance = int $distance;
	    say "  $n->{id}: ($n->{lat}, $n->{lon})";
	    $suggested{$n} = 1;
	}
    }
}

# Don't warn about every OSM box in that rectangle, just those that
# have the ref asked for.  (TODO find a convex hull or something.)
#
foreach (@osm_postbox_nodes) {
    next if $has_unambiguous{$_};
    next if $suggested{$_};
    my $ref = $_->{ref};
    next if not defined $ref;
    next unless $ref =~ /\A$postcode_prefix /o;
    say "$_->{id}: not in Dracos data";
}

