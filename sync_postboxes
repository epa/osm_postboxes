#!/usr/bin/perl
use Modern::Perl;
use File::Slurp;
use List::Util qw(min max);
use List::MoreUtils qw(uniq);
use Tie::RefHash;
use lib '.';
use OSM;

my $postboxes_data_file = 'postboxes.tsv';
if (not -e $postboxes_data_file) {
    my $uri = 'http://www.dracos.co.uk/play/locating-postboxes/export.php';
    die "$postboxes_data_file not there, fetch it from:\n$uri\n";
}

die "usage: $0 postcode-prefix\ne.g. $0 E10\n" if @ARGV != 1;
my $postcode_prefix = shift;
$postcode_prefix =~ /\A[A-Z]+[0-9]+\z/
    or die "bad postcode prefix $postcode_prefix\n";

my @postbox_data;
foreach (read_file $postboxes_data_file) {
    my %h;
    @h{qw(ref postcode loc1 loc2 lat lon)} = split /\t/;
    next unless $h{ref} =~ /\A$postcode_prefix\s/o;
    die unless $h{postcode} =~ /\A$postcode_prefix\s/o;
    push @postbox_data, \%h;
    say "adding pobox at $h{lat} $h{lon}";
}
my @lats = map { $_->{lat} } @postbox_data;
my @lons = map { $_->{lon} } @postbox_data;
my $min_lat = min @lats;
my $max_lat = max @lats;
my $min_lon = min @lons;
my $max_lon = max @lons;
say "unpadded bbox: $min_lon $min_lat $max_lon $max_lat";

my $centre_lat = ($min_lat + $max_lat) / 2;
my $centre_lon = ($min_lon + $max_lon) / 2;

my $MAX_DISTANCE = 100;
my $padding_lat
    = OSM::height_to_lat_degrees $centre_lat, $centre_lon, $MAX_DISTANCE;
my $padding_lon
    = OSM::width_to_lon_degrees $centre_lat, $centre_lon, $MAX_DISTANCE;

$min_lat -= $padding_lat;
$max_lat += $padding_lat;
$min_lon -= $padding_lon;
$max_lon += $padding_lon;
say "padded bbox: $min_lon $min_lat $max_lon $max_lat";

say 'fetching';
my $data = OSM::get_area_bbox $min_lon, $min_lat, $max_lon, $max_lat;

say 'parsing';
my @nodes = OSM::parse_nodes $data;
my @osm_postbox_nodes
    = grep { exists $_->{amenity} and $_->{amenity} eq 'post_box' } @nodes;
use Data::Dump qw(dump);

# Given one data point, find the closest to it in a list of others,
# subject to $MAX_DISTANCE.
#
sub find_closest {
    my ($box, @others) = @_;
    my $lat = $box->{lat};
    my $lon = $box->{lon};
    my ($closest, $closest_distance);
    foreach my $n (@others) {
	my ($nlat, $nlon) = ($n->{lat}, $n->{lon});
	my $distance = OSM::distance $lat, $lon, $nlat, $nlon;
	next if $distance > $MAX_DISTANCE;
	if (not defined $closest_distance or $distance < $closest_distance) {
	    $closest = $n;
	    $closest_distance = $distance;
	}
    }
    return $closest;
}

# Find unambiguous is-closest-to matches.
my %closest_osm_to_dracos;
tie %closest_osm_to_dracos, 'Tie::RefHash' or die;
foreach (@postbox_data) {
    my $closest = find_closest $_, @osm_postbox_nodes;
    $closest_osm_to_dracos{$_} = $closest if $closest;
}
my %closest_dracos_to_osm;
tie %closest_dracos_to_osm, 'Tie::RefHash' or die;
foreach (@osm_postbox_nodes) {
    my $closest = find_closest $_, @postbox_data;
    $closest_dracos_to_osm{$_} = $closest if $closest;
}
my @unambiguous;
foreach my $d (keys %closest_osm_to_dracos) {
    my $o = $closest_osm_to_dracos{$d};
    my $got = $closest_dracos_to_osm{$o};
    if (defined $got and $got eq $d) {
	push @unambiguous, [ $d, $o ];
    }
}
use Data::Dump qw(dump);
say dump @unambiguous;
