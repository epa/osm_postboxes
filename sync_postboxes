#!/usr/bin/perl
use Modern::Perl;
use File::Slurp;
use List::Util qw(min max);
use List::MoreUtils qw(uniq);
use Tie::RefHash;
use Date::Manip;
use lib '.';
use OSM;

my $postboxes_data_file = 'postboxes.tsv';
if (not -e $postboxes_data_file) {
    my $uri = 'http://www.dracos.co.uk/play/locating-postboxes/export.php';
    die "$postboxes_data_file not there, fetch it from:\n$uri\n";
}

die "usage: $0 postcode-prefix\ne.g. $0 E10\n" if @ARGV != 1;
my $postcode_prefix = shift;
$postcode_prefix =~ /\A[A-Z]+[0-9]+\z/
    or die "bad postcode prefix $postcode_prefix\n";

# Read the Dracos file.  The fields are the same as in the header.
my @postbox_data;
foreach (read_file $postboxes_data_file) {
    my %h;
    @h{qw(ref postcode loc1 loc2 lat lon)} = split /\t/;
    next unless $h{ref} =~ /\A$postcode_prefix\s/o;
    die "postcode $h{postcode} does not match ref $h{ref}"
	unless $h{postcode} =~ /\A$postcode_prefix/o;
    foreach (keys %h) {
	delete $h{$_} if $h{$_} !~ /\S/;
    }
    push @postbox_data, \%h;
}
warn scalar(@postbox_data),
    " post boxes found in $postboxes_data_file for $postcode_prefix\n";
die if not @postbox_data;

# Process the Dracos entries breaking up the information a bit.
foreach (@postbox_data) {
    $_->{operator} = 'Royal Mail'; # might as well assume this
    my ($housenumber, $street, $postcode);
    my $loc1 = delete($_->{loc1});
    if ($loc1 =~ /\A(\d+) (.+) ([A-Z]+\d+)\z/) {
	($housenumber, $street, $postcode) = ($1, $2, $3);
    }
    elsif ($loc1 =~ /\A(\d+) (.+)\z/) {
	($housenumber, $street) = ($1, $2);
    }
    else {
	$street = $loc1;
    }
    $_->{'addr:housenumber'} = $housenumber if defined $housenumber;
    $_->{'addr:street'} = $street if defined $housenumber;
    if (defined $postcode and $_->{postcode} !~ /\A$postcode /) {
	if ($_->{postcode} =~ /\A${postcode}(\d)\z/) {
	    # A simple missing space, most likely.
	    $_->{postcode} = "$postcode $1";
	}
	else {
	    warn "inconsistency in Dracos data: box with $_->{postcode} has $postcode in loc1\n";
	}
    }

    # loc2, if present, gives the intersection street.  We don't do
    # anything with this yet, since addr:street holds just the main one.
    #
    delete $_->{loc2};

    # Rename this to the standard OSM name.
    $_->{postal_code} = delete $_->{postcode};
}

my @lats = map { $_->{lat} } @postbox_data;
my @lons = map { $_->{lon} } @postbox_data;
my $min_lat = min @lats;
my $max_lat = max @lats;
my $min_lon = min @lons;
my $max_lon = max @lons;

# Maximum distance for matching two postbox positions.
my $MAX_DISTANCE = 100;

# Pad the bounding box to find postboxes near the positions given.
my $centre_lat = ($min_lat + $max_lat) / 2;
my $centre_lon = ($min_lon + $max_lon) / 2;
my $padding_lat
    = OSM::height_to_lat_degrees $centre_lat, $centre_lon, $MAX_DISTANCE;
my $padding_lon
    = OSM::width_to_lon_degrees $centre_lat, $centre_lon, $MAX_DISTANCE;
$min_lat -= $padding_lat;
$max_lat += $padding_lat;
$min_lon -= $padding_lon;
$max_lon += $padding_lon;

# Sanity check we're not getting too much.
my $MAX_FETCH_SIZE = 30_000;
my $corner_distance = int OSM::distance $min_lat, $min_lon, $max_lat, $max_lon;
die "too large an area to fetch: $corner_distance metres corner to corner\n"
    if $corner_distance > $MAX_FETCH_SIZE;
warn "fetching area $corner_distance metres from corner to corner\n";

{
    my ($got_centre_lat, $got_centre_lon, $zoom)
	= OSM::bbox_to_zoom($min_lon, $min_lat, $max_lon, $max_lat);
    my $uri
	= sprintf 'http://www.openstreetmap.org/?lat=%.6f&lon=%.6f&zoom=%d',
	$got_centre_lat, $got_centre_lon, $zoom;
    warn "<$uri>\n";
}

my $data = OSM::get_area_bbox $min_lon, $min_lat, $max_lon, $max_lat;

warn "parsing\n";
my @nodes = OSM::parse_nodes $data;
my @osm_postbox_nodes
    = grep { exists $_->{amenity} and $_->{amenity} eq 'post_box' } @nodes;
warn scalar(@osm_postbox_nodes) . " nearby post boxes found in OSM\n";

# Given one data point, find the closest to it in a list of others,
# subject to $MAX_DISTANCE.
#
sub find_closest {
    my ($box, @others) = @_;
    my $lat = $box->{lat};
    my $lon = $box->{lon};
    my ($closest, $closest_distance);
    foreach my $n (@others) {
	my ($nlat, $nlon) = ($n->{lat}, $n->{lon});
	my $distance = OSM::distance $lat, $lon, $nlat, $nlon;
	next if $distance > $MAX_DISTANCE;
	if (not defined $closest_distance or $distance < $closest_distance) {
	    $closest = $n;
	    $closest_distance = $distance;
	}
    }
    return $closest;
}

# Find unambiguous is-closest-to matches.
my %closest_osm_to_dracos;
tie %closest_osm_to_dracos, 'Tie::RefHash' or die;
foreach (@postbox_data) {
    my $closest = find_closest $_, @osm_postbox_nodes;
    $closest_osm_to_dracos{$_} = $closest if $closest;
}
my %closest_dracos_to_osm;
tie %closest_dracos_to_osm, 'Tie::RefHash' or die;
foreach (@osm_postbox_nodes) {
    my $closest = find_closest $_, @postbox_data;
    $closest_dracos_to_osm{$_} = $closest if $closest;
}
my @unambiguous;
foreach my $d (keys %closest_osm_to_dracos) {
    my $o = $closest_osm_to_dracos{$d};
    my $got = $closest_dracos_to_osm{$o};
    if (defined $got and $got eq $d) {
	push @unambiguous, [ $d, $o ];
    }
}

my @attr_changes;
use constant EPSILON => 1;
foreach (@unambiguous) {
    my %dracos = %{$_->[0]};
    my %osm = %{$_->[1]};
    my %osm_new = %osm;
    my $changed = 0;
    my $distance = OSM::distance delete($dracos{lat}), delete($dracos{lon}),
                                 delete($osm{lat}), delete($osm{lon});
    delete($osm{amenity}) eq 'post_box' or die;
    my $id = delete $osm{id};
    my $version = delete $osm{version};

    # Check postal code.
    my $dracos_postal_code = delete $dracos{postal_code};
    my $osm_postal_code = delete $osm{postal_code};
    if (defined $dracos_postal_code and defined $osm_postal_code) {
	if ($dracos_postal_code eq $osm_postal_code) {
	    # OK.
	}
	elsif ($osm_postal_code =~ /\A${dracos_postal_code}\d+\z/) {
	    # The OSM one is more detailed.  Do not warn.
	}
	elsif ($dracos_postal_code =~ /\A$osm_postal_code/) {
	    $osm_new{postal_code} = $dracos_postal_code;
	    $changed = 1;
	}
	else {
	    warn qq{$id $version: postal_code $osm_postal_code is inconsistent with Dracos $dracos_postal_code\n};
	}
    }

    # Check 'ref' - sometimes on the map two are given.
    if (defined $dracos{ref} and defined $osm{ref} and $osm{ref} =~ tr/;//) {
	my $d = delete $dracos{ref};
	my @o = split /;\s*/, delete $osm{ref};
	if (@o ~~ $d) {
	    # OK, this ref is there, plus some others.
	}
	else {
	    warn qq{$id $version: refs (@o) are inconsistent with Dracos $d\n};
	}
    }

    foreach (sort keys %dracos) {
        my $d = $dracos{$_};
        my $o = $osm{$_};
        if (not defined $o) {
	    $osm_new{$_} = $d;
	    $changed = 1;
	}
	elsif ($d ne $o) {
	    warn qq{$id $version: discrepancy: Dracos $_="$d" vs OSM $_="$o"\n};
	}
    }

    if ($changed) {
	$osm_new{source} //= 'dracos';
	push @attr_changes, \%osm_new;
    }
}

my %has_unambiguous;
foreach (@unambiguous) {
    foreach (@$_) {
	$has_unambiguous{$_}++ && die;
    }
}

my @new_nodes;
my %suggested;
foreach my $d (@postbox_data) {
    next if $has_unambiguous{$d};
    my $lat = $d->{lat};
    my $lon = $d->{lon};
    my $loc1 = $d->{loc1};
    my $ref = $d->{ref};
    my $postal_code = $d->{postal_code};
    my $operator = $d->{operator};

    # Find nearby unmatched OSM nodes.
    my @osm_with_distance
	= map { [ $_, OSM::distance $lat, $lon, $_->{lat}, $_->{lon} ] }
    @osm_postbox_nodes;
    @osm_with_distance = grep { $_->[1] <= $MAX_DISTANCE } @osm_with_distance;
    @osm_with_distance
	= reverse sort { $a->[1] <=> $b->[1] } @osm_with_distance;

    if (@osm_with_distance) {
	my $msg = sprintf
	     'to add at (%.6f, %.6f), ref="%s", postal_code="%s"',
	     $lat, $lon, $ref, $postal_code;
	 warn "$msg\n";
	 warn "...but has nearby OSM postboxes:\n";
	foreach (@osm_with_distance) {
	    my ($n, $distance) = @$_;
	    $distance = int $distance;
	    print STDERR "  $n->{id} $n->{version}: $distance metres away ($n->{lat}, $n->{lon})\n";
            print STDERR '   (already matched)' if $has_unambiguous{$n};
            print STDERR "\n";
	    $suggested{$n} = 1;
	}
    }
    else {
	# Nothing nearby, we can safely add the new node.
	my $node_id = -(scalar(@new_nodes) + 1);
	my %h = (
	    id => $node_id, lat => $lat, lon => $lon,
	    amenity => 'post_box', ref => $ref, 
	    postal_code => $postal_code, operator => $operator,
	    source => 'dracos', 'dracos:verified' => 'no',
	    );
	foreach ('addr:housenumber', 'addr:street') {
	    $h{$_} = $d->{$_} if exists $d->{$_};
	}
	push @new_nodes, \%h;
    }
}

# Don't warn about every OSM box in that rectangle, just those that
# have the ref asked for.  (TODO find a convex hull or something.)
#
foreach (@osm_postbox_nodes) {
    next if $has_unambiguous{$_};
    next if $suggested{$_};
    my $ref = $_->{ref};
    next if not defined $ref;
    next unless $ref =~ /\A$postcode_prefix /o;
    warn "$_->{id}: not in Dracos data\n";
}

my $timestamp = UnixDate 'now', '%O'; # FIXME requires UTC time
my $changeset = 999;
sub write_node {
    my %h = %{shift()};

    # First get out the standard attrs.
    my %a;
    $a{$_} = delete $h{$_} foreach qw(id lat lon version);
    $a{version} //= 0;
    $a{timestamp} = $timestamp;
    $a{changeset} = $changeset;
    my $attr_str
	= join ' ', map { $_ . '="' . delete($a{$_}) . '"' } sort keys %a;
    say "    <node $attr_str>";
    foreach (sort keys %h) {
	say qq{      <tag k="$_" v="$h{$_}" />};
    }
    say '    </node>';
}

my $gunk = 'version="0.3" generator="sync_postboxes"';
exit if not @attr_changes and not @new_nodes;
say "<osmChange $gunk>";
foreach (sort { $a->{id} <=> $b->{id} } @attr_changes) {
    say "  <modify $gunk>";
    write_node $_;
    say '  </modify>';
}
foreach (reverse sort { $a->{id} <=> $b->{id} } @new_nodes) {
    say "  <create $gunk>";
    write_node $_;
    say '  </create>';
}
say '</osmChange>';

    
